#!/usr/bin/env node\n\n/**\n * Socket Server Health Monitoring Script\n * \n * This script can be used by external monitoring tools (Nagios, Zabbix, etc.)\n * to check the health of the Socket.IO server and trigger alerts.\n * \n * Usage:\n *   node monitor-socket-health.js [options]\n * \n * Options:\n *   --url <url>          Base URL of the application (default: http://localhost:3000)\n *   --admin-token <token> Admin JWT token for detailed monitoring\n *   --format <format>    Output format: json, nagios, prometheus (default: json)\n *   --warning <threshold> Warning threshold for response time in ms (default: 1000)\n *   --critical <threshold> Critical threshold for response time in ms (default: 5000)\n *   --memory-warning <percent> Memory usage warning threshold (default: 80)\n *   --memory-critical <percent> Memory usage critical threshold (default: 90)\n *   --error-rate-warning <percent> Error rate warning threshold (default: 5)\n *   --error-rate-critical <percent> Error rate critical threshold (default: 10)\n *   --help               Show this help message\n */\n\nconst https = require('https');\nconst http = require('http');\nconst { URL } = require('url');\nconst { performance } = require('perf_hooks');\n\nclass SocketHealthMonitor {\n  constructor(options = {}) {\n    this.options = {\n      url: options.url || 'http://localhost:3000',\n      adminToken: options.adminToken,\n      format: options.format || 'json',\n      warningThreshold: options.warning || 1000,\n      criticalThreshold: options.critical || 5000,\n      memoryWarning: options.memoryWarning || 80,\n      memoryCritical: options.memoryCritical || 90,\n      errorRateWarning: options.errorRateWarning || 5,\n      errorRateCritical: options.errorRateCritical || 10,\n      timeout: options.timeout || 30000,\n    };\n    \n    this.exitCodes = {\n      OK: 0,\n      WARNING: 1,\n      CRITICAL: 2,\n      UNKNOWN: 3,\n    };\n    \n    this.status = {\n      code: this.exitCodes.OK,\n      message: 'OK',\n      details: {},\n      metrics: {},\n      alerts: [],\n    };\n  }\n  \n  async makeRequest(endpoint, options = {}) {\n    const url = new URL(endpoint, this.options.url);\n    const isHttps = url.protocol === 'https:';\n    const client = isHttps ? https : http;\n    \n    const requestOptions = {\n      hostname: url.hostname,\n      port: url.port || (isHttps ? 443 : 80),\n      path: url.pathname + url.search,\n      method: options.method || 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        'User-Agent': 'Socket-Health-Monitor/1.0',\n        ...options.headers,\n      },\n      timeout: this.options.timeout,\n    };\n    \n    if (this.options.adminToken) {\n      requestOptions.headers.Authorization = `Bearer ${this.options.adminToken}`;\n    }\n    \n    return new Promise((resolve, reject) => {\n      const startTime = performance.now();\n      \n      const req = client.request(requestOptions, (res) => {\n        let data = '';\n        \n        res.on('data', (chunk) => {\n          data += chunk;\n        });\n        \n        res.on('end', () => {\n          const responseTime = performance.now() - startTime;\n          \n          try {\n            const parsedData = JSON.parse(data);\n            resolve({\n              statusCode: res.statusCode,\n              headers: res.headers,\n              data: parsedData,\n              responseTime,\n            });\n          } catch (parseError) {\n            resolve({\n              statusCode: res.statusCode,\n              headers: res.headers,\n              data: data,\n              responseTime,\n            });\n          }\n        });\n      });\n      \n      req.on('error', reject);\n      req.on('timeout', () => {\n        req.destroy();\n        reject(new Error('Request timeout'));\n      });\n      \n      if (options.body) {\n        req.write(JSON.stringify(options.body));\n      }\n      \n      req.end();\n    });\n  }\n  \n  async checkBasicHealth() {\n    try {\n      const response = await this.makeRequest('/api/health/socket');\n      \n      this.status.metrics.responseTime = response.responseTime;\n      this.status.metrics.httpStatus = response.statusCode;\n      \n      if (response.statusCode !== 200) {\n        this.updateStatus(\n          this.exitCodes.CRITICAL,\n          `HTTP ${response.statusCode}: ${response.data.error || 'Unknown error'}`\n        );\n        return false;\n      }\n      \n      if (response.responseTime > this.options.criticalThreshold) {\n        this.updateStatus(\n          this.exitCodes.CRITICAL,\n          `Response time critical: ${response.responseTime.toFixed(2)}ms`\n        );\n      } else if (response.responseTime > this.options.warningThreshold) {\n        this.updateStatus(\n          this.exitCodes.WARNING,\n          `Response time warning: ${response.responseTime.toFixed(2)}ms`\n        );\n      }\n      \n      const healthData = response.data;\n      this.status.details.health = healthData;\n      \n      // Check overall health status\n      if (healthData.status === 'unhealthy') {\n        this.updateStatus(\n          this.exitCodes.CRITICAL,\n          `Server unhealthy: ${healthData.details.issues?.join(', ') || 'Unknown issues'}`\n        );\n      } else if (healthData.status === 'degraded') {\n        this.updateStatus(\n          this.exitCodes.WARNING,\n          `Server degraded: ${healthData.details.issues?.join(', ') || 'Performance issues'}`\n        );\n      }\n      \n      // Check memory usage\n      if (healthData.details.system?.memory) {\n        const memoryUsage = (healthData.details.system.memory.heapUsed / healthData.details.system.memory.heapTotal) * 100;\n        this.status.metrics.memoryUsage = memoryUsage;\n        \n        if (memoryUsage > this.options.memoryCritical) {\n          this.updateStatus(\n            this.exitCodes.CRITICAL,\n            `Memory usage critical: ${memoryUsage.toFixed(1)}%`\n          );\n        } else if (memoryUsage > this.options.memoryWarning) {\n          this.updateStatus(\n            this.exitCodes.WARNING,\n            `Memory usage warning: ${memoryUsage.toFixed(1)}%`\n          );\n        }\n      }\n      \n      // Check circuit breakers\n      if (healthData.details.circuitBreakers) {\n        const openBreakers = Object.entries(healthData.details.circuitBreakers)\n          .filter(([_, breaker]) => breaker.status === 'open')\n          .map(([service, _]) => service);\n        \n        if (openBreakers.length > 0) {\n          this.updateStatus(\n            this.exitCodes.CRITICAL,\n            `Circuit breakers open: ${openBreakers.join(', ')}`\n          );\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      this.updateStatus(\n        this.exitCodes.CRITICAL,\n        `Health check failed: ${error.message}`\n      );\n      return false;\n    }\n  }\n  \n  async checkDetailedHealth() {\n    if (!this.options.adminToken) {\n      return;\n    }\n    \n    try {\n      const response = await this.makeRequest('/api/health/socket', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.options.adminToken}`,\n        },\n      });\n      \n      if (response.statusCode !== 200) {\n        this.addAlert('warning', `Admin health check failed: HTTP ${response.statusCode}`);\n        return;\n      }\n      \n      const healthData = response.data;\n      this.status.details.adminHealth = healthData;\n      \n      // Check error rate\n      if (healthData.performance?.errorRate) {\n        const errorRate = healthData.performance.errorRate * 100;\n        this.status.metrics.errorRate = errorRate;\n        \n        if (errorRate > this.options.errorRateCritical) {\n          this.updateStatus(\n            this.exitCodes.CRITICAL,\n            `Error rate critical: ${errorRate.toFixed(2)}%`\n          );\n        } else if (errorRate > this.options.errorRateWarning) {\n          this.updateStatus(\n            this.exitCodes.WARNING,\n            `Error rate warning: ${errorRate.toFixed(2)}%`\n          );\n        }\n      }\n      \n      // Check connection limits\n      if (healthData.connections) {\n        this.status.metrics.activeConnections = healthData.connections.summary.total;\n        this.status.metrics.authenticatedConnections = healthData.connections.summary.authenticated;\n        \n        // Alert if too many connections\n        if (healthData.connections.summary.total > 1000) {\n          this.addAlert('warning', `High connection count: ${healthData.connections.summary.total}`);\n        }\n      }\n      \n      // Check maintenance mode\n      if (healthData.maintenanceMode) {\n        this.addAlert('warning', 'Server is in maintenance mode');\n      }\n      \n      // Check for recent admin commands\n      if (healthData.admin?.commandHistory) {\n        const recentCommands = healthData.admin.commandHistory.filter(cmd => \n          Date.now() - cmd.timestamp < 300000 // Last 5 minutes\n        );\n        \n        if (recentCommands.length > 0) {\n          this.addAlert('info', `Recent admin commands: ${recentCommands.length}`);\n        }\n      }\n      \n    } catch (error) {\n      this.addAlert('warning', `Detailed health check failed: ${error.message}`);\n    }\n  }\n  \n  updateStatus(code, message) {\n    if (code > this.status.code) {\n      this.status.code = code;\n      this.status.message = message;\n    }\n  }\n  \n  addAlert(level, message) {\n    this.status.alerts.push({ level, message, timestamp: Date.now() });\n  }\n  \n  formatOutput() {\n    const timestamp = new Date().toISOString();\n    \n    switch (this.options.format) {\n      case 'nagios':\n        return this.formatNagiosOutput();\n      \n      case 'prometheus':\n        return this.formatPrometheusOutput();\n      \n      case 'json':\n      default:\n        return JSON.stringify({\n          timestamp,\n          status: this.getStatusText(),\n          code: this.status.code,\n          message: this.status.message,\n          metrics: this.status.metrics,\n          alerts: this.status.alerts,\n          details: this.status.details,\n        }, null, 2);\n    }\n  }\n  \n  formatNagiosOutput() {\n    const statusText = this.getStatusText();\n    const perfData = this.generatePerfData();\n    \n    return `${statusText}: ${this.status.message}${perfData ? ` | ${perfData}` : ''}`;\n  }\n  \n  formatPrometheusOutput() {\n    const timestamp = Date.now();\n    const metrics = [];\n    \n    // Health status (0=OK, 1=WARNING, 2=CRITICAL, 3=UNKNOWN)\n    metrics.push(`socket_health_status{instance=\"${this.options.url}\"} ${this.status.code} ${timestamp}`);\n    \n    // Response time\n    if (this.status.metrics.responseTime) {\n      metrics.push(`socket_health_response_time_ms{instance=\"${this.options.url}\"} ${this.status.metrics.responseTime.toFixed(2)} ${timestamp}`);\n    }\n    \n    // Memory usage\n    if (this.status.metrics.memoryUsage) {\n      metrics.push(`socket_health_memory_usage_percent{instance=\"${this.options.url}\"} ${this.status.metrics.memoryUsage.toFixed(2)} ${timestamp}`);\n    }\n    \n    // Error rate\n    if (this.status.metrics.errorRate) {\n      metrics.push(`socket_health_error_rate_percent{instance=\"${this.options.url}\"} ${this.status.metrics.errorRate.toFixed(2)} ${timestamp}`);\n    }\n    \n    // Connection count\n    if (this.status.metrics.activeConnections) {\n      metrics.push(`socket_health_active_connections{instance=\"${this.options.url}\"} ${this.status.metrics.activeConnections} ${timestamp}`);\n    }\n    \n    // Authenticated connections\n    if (this.status.metrics.authenticatedConnections) {\n      metrics.push(`socket_health_authenticated_connections{instance=\"${this.options.url}\"} ${this.status.metrics.authenticatedConnections} ${timestamp}`);\n    }\n    \n    return metrics.join('\\n');\n  }\n  \n  generatePerfData() {\n    const perfData = [];\n    \n    if (this.status.metrics.responseTime) {\n      perfData.push(`response_time=${this.status.metrics.responseTime.toFixed(2)}ms;${this.options.warningThreshold};${this.options.criticalThreshold}`);\n    }\n    \n    if (this.status.metrics.memoryUsage) {\n      perfData.push(`memory_usage=${this.status.metrics.memoryUsage.toFixed(1)}%;${this.options.memoryWarning};${this.options.memoryCritical}`);\n    }\n    \n    if (this.status.metrics.errorRate) {\n      perfData.push(`error_rate=${this.status.metrics.errorRate.toFixed(2)}%;${this.options.errorRateWarning};${this.options.errorRateCritical}`);\n    }\n    \n    if (this.status.metrics.activeConnections) {\n      perfData.push(`active_connections=${this.status.metrics.activeConnections}`);\n    }\n    \n    return perfData.join(' ');\n  }\n  \n  getStatusText() {\n    switch (this.status.code) {\n      case this.exitCodes.OK:\n        return 'OK';\n      case this.exitCodes.WARNING:\n        return 'WARNING';\n      case this.exitCodes.CRITICAL:\n        return 'CRITICAL';\n      case this.exitCodes.UNKNOWN:\n      default:\n        return 'UNKNOWN';\n    }\n  }\n  \n  async run() {\n    try {\n      await this.checkBasicHealth();\n      await this.checkDetailedHealth();\n      \n      console.log(this.formatOutput());\n      process.exit(this.status.code);\n    } catch (error) {\n      console.error(JSON.stringify({\n        timestamp: new Date().toISOString(),\n        status: 'UNKNOWN',\n        code: this.exitCodes.UNKNOWN,\n        message: `Monitor failed: ${error.message}`,\n        error: error.stack,\n      }, null, 2));\n      process.exit(this.exitCodes.UNKNOWN);\n    }\n  }\n}\n\n// CLI argument parsing\nfunction parseArgs() {\n  const args = process.argv.slice(2);\n  const options = {};\n  \n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    \n    switch (arg) {\n      case '--url':\n        options.url = args[++i];\n        break;\n      case '--admin-token':\n        options.adminToken = args[++i];\n        break;\n      case '--format':\n        options.format = args[++i];\n        break;\n      case '--warning':\n        options.warning = parseInt(args[++i]);\n        break;\n      case '--critical':\n        options.critical = parseInt(args[++i]);\n        break;\n      case '--memory-warning':\n        options.memoryWarning = parseInt(args[++i]);\n        break;\n      case '--memory-critical':\n        options.memoryCritical = parseInt(args[++i]);\n        break;\n      case '--error-rate-warning':\n        options.errorRateWarning = parseInt(args[++i]);\n        break;\n      case '--error-rate-critical':\n        options.errorRateCritical = parseInt(args[++i]);\n        break;\n      case '--timeout':\n        options.timeout = parseInt(args[++i]);\n        break;\n      case '--help':\n        console.log(`\nSocket Server Health Monitor\n\nUsage: node monitor-socket-health.js [options]\n\nOptions:\n  --url <url>                    Base URL (default: http://localhost:3000)\n  --admin-token <token>          Admin JWT token for detailed monitoring\n  --format <format>              Output format: json, nagios, prometheus (default: json)\n  --warning <ms>                 Warning threshold for response time (default: 1000)\n  --critical <ms>                Critical threshold for response time (default: 5000)\n  --memory-warning <percent>     Memory usage warning threshold (default: 80)\n  --memory-critical <percent>    Memory usage critical threshold (default: 90)\n  --error-rate-warning <percent> Error rate warning threshold (default: 5)\n  --error-rate-critical <percent> Error rate critical threshold (default: 10)\n  --timeout <ms>                 Request timeout (default: 30000)\n  --help                         Show this help\n\nExamples:\n  node monitor-socket-health.js --url https://app.vasquezlaw.com\n  node monitor-socket-health.js --format nagios --warning 500 --critical 2000\n  node monitor-socket-health.js --format prometheus --admin-token eyJ0eXAiOi...\n`);\n        process.exit(0);\n        break;\n    }\n  }\n  \n  return options;\n}\n\n// Main execution\nif (require.main === module) {\n  const options = parseArgs();\n  const monitor = new SocketHealthMonitor(options);\n  monitor.run();\n}\n\nmodule.exports = SocketHealthMonitor;
